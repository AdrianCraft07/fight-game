"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const consts_1 = require("../consts");
const Errors_1 = require("../utils/Errors");
const validateType_1 = require("../utils/validateType");
const betterRequest_1 = require("./betterRequest");
const validatePath_1 = __importDefault(require("./validatePath"));
function isMethodRouter(obj) {
    return obj instanceof Router || (0, validateType_1.isWagaHandlerCallback)(obj);
}
class Router {
    #methods = {
        GET: [],
        POST: [],
        PUT: [],
        DELETE: [],
        USE: [],
    };
    #routers = [];
    get _methods() {
        return this.#methods;
    }
    __active__() {
        const useRouters = Boolean(this.#routers.length);
        // An external function is used so that the function does not have to be re-created each time the method is called
        if (useRouters)
            for (const [path, router] of this.#routers) {
                const routerMethods = router.__active__();
                for (const method in routerMethods) {
                    const routerHandlers = routerMethods[method];
                    for (const routerHandler of routerHandlers) {
                        const _path = (0, betterRequest_1.clearPath)(`${path === '*' ? '' : path}${routerHandler.path}`);
                        const handler = this.#methods[method].find(handler => handler.path === _path);
                        if (!handler)
                            this.#methods[method].unshift({
                                path: _path,
                                validate: (0, validatePath_1.default)(_path),
                                value: routerHandler.value,
                                length: _path.split('/').length,
                            });
                        else
                            handler.value.unshift(...routerHandler.value);
                    }
                }
            }
        return this.#methods;
    }
    _setMethod(method, path, handlerCallback) {
        if (!consts_1.METHODS.includes(method))
            throw new Errors_1.InvalidMethod(`"${method}" is not a valid method`);
        if (typeof path !== 'string')
            throw new TypeError(`"path" must be a string`);
        if (!(0, validateType_1.isIterableWith)(handlerCallback, validateType_1.isWagaHandlerCallback))
            throw new Errors_1.InvalidElement(`"handlerCallback" must be a array of WagaHandlerCallback`);
        const _path = (0, betterRequest_1.clearPath)(path);
        const handler = this.#methods[method].find(handler => handler.path === _path);
        if (!handler)
            this.#methods[method].unshift({
                path: _path,
                validate: (0, validatePath_1.default)(_path),
                value: handlerCallback,
                length: _path.split('/').length,
            });
        else
            handler.value.unshift(...handlerCallback);
    }
    get(path, ...handlerCallback) {
        this._setMethod('GET', path, handlerCallback);
        return this;
    }
    post(path, ...handlerCallback) {
        this._setMethod('POST', path, handlerCallback);
        return this;
    }
    put(path, ...handlerCallback) {
        this._setMethod('PUT', path, handlerCallback);
        return this;
    }
    delete(path, ...handlerCallback) {
        this._setMethod('DELETE', path, handlerCallback);
        return this;
    }
    use() {
        let [path, ...handlerCallback] = [...arguments];
        if (typeof path !== 'string')
            if (isMethodRouter(path)) {
                handlerCallback.unshift(path);
                path = '*';
            }
            else
                throw new TypeError(`"path" must be a string, Router or WagaHandlerCallback`);
        if (!(0, validateType_1.isIterableWith)(handlerCallback, isMethodRouter))
            throw new Errors_1.InvalidElement(`"handlerCallback" must be a array of WagaHandlerCallback or Router`);
        for (const handler of handlerCallback) {
            if (handler instanceof Router)
                this.#routers.push([path, handler]);
            else
                this._setMethod('USE', path, [handler]);
        }
        return this;
    }
}
module.exports = Router;
