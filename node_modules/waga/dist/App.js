"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = __importDefault(require("http"));
const router_1 = __importDefault(require("./lib/router"));
const betterRequest_1 = __importDefault(require("./lib/betterRequest"));
const betterResponse_1 = __importDefault(require("./lib/betterResponse"));
const bodyParser_1 = __importDefault(require("./lib/bodyParser"));
const fileType_1 = __importDefault(require("./utils/fileType"));
const FN = () => { };
const html404 = ['<h1>404 Not Found</h1>', '<h3>Server: Waga</h3>', '<style>body{text-align: center;font-family: system-ui;}</style>'];
const e404 = (req, res) => {
    if (req.accepts('html')) {
        return res.status(404).send(`${html404[0]}<h2>${req.method} ${req.path}</h2>${html404[1]}${html404[2]}`);
    }
    if (req.accepts('json'))
        return res.status(404).send({ error: 'Not Found', method: req.method, url: req.url, status: 404, server: 'Waga' });
    return res.status(404).send('Not Found');
};
class App extends router_1.default {
    constructor() {
        super();
    }
    #TypeFiles = {};
    getTypeFile(path) {
        const ext = path.split('.').pop()?.toLowerCase();
        return this.#TypeFiles[ext] || (0, fileType_1.default)(path);
    }
    setTypeFile(ext, type) {
        this.#TypeFiles[ext] = type;
        return this;
    }
    listen(port, callback = FN) {
        if (typeof callback !== 'function')
            throw new TypeError('Callback must be a function');
        const fn = this.toFunction();
        const server = http_1.default.createServer(fn);
        server.listen(port, () => callback(server.address().port));
        return server;
    }
    getValids(req) {
        const method = req.method;
        const path = req.path;
        const USE = [];
        for (const handler of this._methods.USE) {
            const params = handler.validate(path);
            if (!params)
                continue;
            USE.push({ params, fns: handler.value, length: handler.length, paramsKeys: Object.keys(params).length });
        }
        const METHOD = [];
        for (const handler of this._methods[method]) {
            const params = handler.validate(path);
            if (!params)
                continue;
            METHOD.push({ params, fns: handler.value, length: handler.length, paramsKeys: Object.keys(params).length });
        }
        const methodSort = METHOD.sort((a, b) => {
            if (a.params['*'] && !b.params['*'])
                return 1;
            if (!a.params['*'] && b.params['*'])
                return -1;
            if (a.length === b.length)
                return b.paramsKeys - a.paramsKeys;
            return b.length - a.length;
        });
        USE.push(...methodSort);
        return USE;
    }
    toFunction() {
        this.__active__();
        return async (request, response) => {
            request.body = await (0, bodyParser_1.default)(request, response);
            betterRequest_1.default.call(this, request, response, next);
            betterResponse_1.default.call(this, request, response, next);
            const valid = this.getValids(request);
            let i = 0;
            function next() {
                const element = valid[i];
                if (!element)
                    return e404(request, response);
                const { fns, params } = element;
                i++;
                if (!fns)
                    return;
                if (fns.length === 0)
                    return next();
                // they are overridden to work with values ​​like "waga.json"
                request.params = params;
                for (const fn of fns)
                    fn(request, response, next);
            }
            next();
        };
    }
}
exports.default = App;
